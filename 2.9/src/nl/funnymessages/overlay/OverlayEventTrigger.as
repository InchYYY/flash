///////////////////////////////////////////////////////////
//  OverlayEventTrigger.as
//  Macromedia ActionScript Implementation of the Class OverlayEventTrigger
//  Generated by Enterprise Architect
//  Created on:      16-jun-2011 12:23:41
//  Original author: Wouter Tengeler
///////////////////////////////////////////////////////////

package nl.funnymessages.overlay
{
	import flash.events.EventDispatcher;
	
	import nl.funnymessages.overlay.OverlayEvent;
	
	import nl.themotionstudio.utils.Debug;
	

	/**
	 * @author Wouter Tengeler
	 * @version 1.0
	 * @created 16-jun-2011 12:23:41
	 */
	public class OverlayEventTrigger extends EventDispatcher
	{
	    static public const EVENT_TYPE_SPEECH: uint = 1;
	    static public const EVENT_TYPE_FILTER: uint = 2;
		
		private var m_aEvents:Array;
		private var m_aFrameList:Array;
		private var m_iFrameIndex:int; 		// index of the last triggered frame in the framelist
		private var m_iLastEventFrame:int;	// The frame of the last handled event
		private var m_iNextEventFrame:int;	// The frame of the next event to handle

		public function OverlayEventTrigger() {
			Debug.addClass('OverlayEventTrigger');
			Debug.traceInfo('OverlayEventTrigger', 'constructor');
			m_aEvents = new Array();
			m_aFrameList = new Array();
			m_iFrameIndex = -1;
			m_iLastEventFrame = -1;
			m_iNextEventFrame = -1;
		}

	    /**
		 * @param uint p_iOverlayIndex 	The index of the overlay for which this event is triggered
		 * @param uint p_iStartFrame	 The frame on which the event starts
		 * @param uint p_iDuration		The duration of the event in frames
		 * @param uint p_iType			The type of the event
		 * @param Object p_oData		Event specific data
		 */
	    public function addEvent(p_iOverlayIndex:uint, p_iStartFrame:uint, p_iDuration:uint, p_iType:uint, p_oData:Object): void
	    {
			if (isValidType(p_iType)) {
				Debug.traceInfo('OverlayEventTrigger', 'addEvent', 'start', p_iStartFrame);
				addStartTrigger(p_iOverlayIndex, p_iStartFrame, p_iDuration, p_iType, p_oData);
				addEndTrigger(p_iOverlayIndex, p_iStartFrame + p_iDuration, p_iType, p_oData);
				m_aFrameList.sort(Array.NUMERIC);
				
			} else {
				throw new Error('Invalid event type');
			}
	    }
		
		/**
		 * handleFrame called from ClipContainer
		 * @param uint p_iCurrentFrame
		 */
		public function handleFrame(p_iCurrentFrame:uint):void {
			if ((m_iFrameIndex < 0) && (m_aFrameList.length > 0)){
				// set index to start
				m_iFrameIndex = 0;
				m_iNextEventFrame = m_aFrameList[m_iFrameIndex]
			}
			if ((m_iFrameIndex >= 0) && (m_iFrameIndex < m_aFrameList.length)) {
				// index is within bounds
				handleFrameEvents(p_iCurrentFrame);
			}
		}
		
		
		/**
		 * Add the trigger for the start of the event
		 * @param uint p_iFrame
		 * @param uint p_iType
		 * @param uint p_oData
		 */
		private function addStartTrigger(p_iOverlayIndex:uint, p_iFrame:uint, p_iDuration:uint, p_iType:uint, p_oData:Object):void {
			addFrame(p_iFrame);
			var oEventInfo:Object = new Object();
			// copy all data to event data
			for (var sProperty:String in p_oData) {
				oEventInfo[sProperty] = p_oData[sProperty];
			}
			oEventInfo.id = p_iOverlayIndex;
			oEventInfo.end = false;
			oEventInfo.type = p_iType;
			oEventInfo.duration = p_iDuration;
			Debug.traceInfo('OverlayEventTrigger', 'addStartTrigger', 'data', oEventInfo);
			// add event to list
			m_aEvents[p_iFrame].push(oEventInfo);
		}
		
		/**
		 * add the trigger for the end of the event
		 * @param uint p_iFrame
		 * @param uint p_iType
		 * @param uint p_oData
		 */
		private function addEndTrigger(p_iOverlayIndex:uint, p_iFrame:uint, p_iType:uint, p_oData:Object):void {
			addFrame(p_iFrame);
			var oEventInfo:Object = new Object();
			// copy all data to event data
			for (var sProperty:String in p_oData) {
				oEventInfo[sProperty] = p_oData[sProperty];
			}
			oEventInfo.id = p_iOverlayIndex;
			oEventInfo.end = true;
			oEventInfo.type = p_iType;
			oEventInfo.duration = 0;
			// add event to list
			m_aEvents[p_iFrame].push(oEventInfo);
		}
		
		/**
		 * add the frame to the list of triggers
		 * @param uint p_iFrame
		 */
		private function addFrame(p_iFrame:uint):void {
			if (undefined == m_aEvents[p_iFrame]) {
				// new frame to have an event on
				m_aEvents[p_iFrame] = new Array();
				// add it to the list
				m_aFrameList.push(p_iFrame);
			}
		}
		
		private function handleFrameEvents(p_iCurrentFrame:uint):void {
			// handle all passed frames to avoid lagging
			while ((m_iNextEventFrame > 0) && (p_iCurrentFrame >= m_iNextEventFrame)) {
				// trigger all event for this frame
				for each (var oEvent: Array in m_aEvents[m_iNextEventFrame]) {
					triggerEvent(oEvent.type, oEvent, oEvent.end);
				}
				// find the next event frame
				m_iFrameIndex++;
				if (m_iFrameIndex < m_aFrameList.length) {
					m_iNextEventFrame = m_aFrameList[m_iFrameIndex];
				} else {
					m_iNextEventFrame = -1;
				}
				Debug.traceInfo('OverlayEventTrigger', 'handleFrameEvents', 'next frame', m_iNextEventFrame);
			}
		}
		
		
		private function triggerEvent(p_iType:uint, p_oData:Object, p_bEnd:Boolean):void {
			var oEvent:OverlayEvent = null;
			switch(p_iType) {
				case EVENT_TYPE_SPEECH : 
					if (!p_bEnd) {
						// start event
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'SPEECH', 'start');
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'data', p_oData);
						dispatchEvent(new OverlayEvent(OverlayEvent.OVERLAY_EVENT_SPEECH_START, false, false, p_oData));
					} else {
						// end event
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'SPEECH', 'end');
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'data', p_oData);
						dispatchEvent(new OverlayEvent(OverlayEvent.OVERLAY_EVENT_SPEECH_END, false, false, p_oData));
					}
				break;
				case EVENT_TYPE_FILTER :
					if (!p_bEnd) {
						// start event
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'FILTER', 'start');
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'data', p_oData);
						dispatchEvent(new OverlayEvent(OverlayEvent.OVERLAY_EVENT_FILTER_START, false, false, p_oData));
					} else {
						// end event
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'FILTER', 'end');
						Debug.traceInfo('OverlayEventTrigger', 'triggerEvent', 'data', p_oData);
						dispatchEvent(new OverlayEvent(OverlayEvent.OVERLAY_EVENT_FILTER_END, false, false, p_oData));
					}
				break;
			}
			// dispatch the event
			if (null != oEvent) {
				dispatchEvent(oEvent);
			}
		}
		
		private function isValidType(p_iType:uint):Boolean {
			if ((p_iType == EVENT_TYPE_SPEECH) || (p_iType == EVENT_TYPE_FILTER)) {
				return true;
			} else {
				return false;
			}
		}

	}//end OverlayEventTrigger

}