///////////////////////////////////////////////////////////
//  ClipContainer.as
//  Macromedia ActionScript Implementation of the Class ClipContainer
//  Generated by Enterprise Architect
//  Created on:      18-okt-2010 13:03:59
//  Original author: Wouter Tengeler
///////////////////////////////////////////////////////////

package nl.funnymessages.clipcontainer
{
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.DisplayObject;
	import flash.display.DisplayObjectContainer;
	import flash.display.MovieClip;
	import flash.events.Event;
	
	import nl.funnymessages.overlay.Overlay;
	import nl.funnymessages.overlay.OverlayEventTrigger;
	import nl.funnymessages.overlay.head.Head;
	import nl.themotionstudio.utils.Debug;

	/**
	 * @author Wouter Tengeler
	 * @version 1.0
	 * @created 18-okt-2010 13:03:59
	 */
	dynamic public class ClipContainer extends MovieClip
	{
		public static const STATUS_UNKNOWN:String            = 'StatusUnknown';
		public static const STATUS_WAITING_FOR_INIT:String   = 'StatusWaitingForInit';
		public static const STATUS_INITIALIZED:String        = 'StatusInitialized';
		public static const STATUS_PLAYING:String            = 'StatusPlaying';
		public static const STATUS_PAUSED:String             = 'StatusPaused';
		public static const STATUS_ENDED:String              = 'StatusEnded';
		public static const STATUS_WAITING_FOR_REPLAY:String = 'StatusWaitingForReplay';
		
		public var CLIP_VERSION:String = '20121112T1354';
		public var currHeadIndex : int;
	    public var m_aHeads: Array;
		private var self : ClipContainer;
		private var m_iNrHeads:int;
		private var m_sStatus:String;
		private var m_sOldStatus:String;
		private var m_iCurrentFrame:int;
	    private var m_oEventTrigger: OverlayEventTrigger;
		private var headChange : Boolean = false;
		private var sayState : String;

		/**
		 * Constructor
		 * Positioned heads in the movieclip should have the instance name head_x 
		 * where x is a integer number starting with 0
		 * 
		 */
	    public function ClipContainer(p_bTestMode:Boolean): void
	    {
			self = this;
			try
			{
				Debug.setDebug(false);
				Debug.addClass('ClipContainer');
				Debug.traceInfo('ClipContainer', 'constructor', 'version', CLIP_VERSION);
				m_aHeads = new Array();
				m_iNrHeads = 0;
				m_iCurrentFrame = 0;
				m_sOldStatus = '';
				// init the event trigger  在这事件触发
				eventTrigger = new OverlayEventTrigger();
				
				// make sure super is called last
				super();
				addEventListener(Event.ENTER_FRAME, onEnterFrame);
				addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
				status = STATUS_UNKNOWN;
				if (p_bTestMode) { }
				else { stop(); }
			}
			catch (e:Error) {
				Debug.traceInfo('ClipContainer', 'constructor', 'Fatal Error', e.message);
			}
	    }
		
		public function setHead(p_iIndex : uint, oBitmap : Bitmap, p_aMarkers : Array) : void
		{
			try
			{
				Debug.traceInfo('ClipContainer', 'setHead', 'head', '');
				// instantiate the classes from the given string   实例化类从给定的字符串
				var oHead:Head = getHead(p_iIndex);
				if (oHead != null)
				{
					oHead.image = oBitmap;
					oHead.createMouth(p_aMarkers);
				}
				else { Debug.traceInfo('ClipContainer', 'setHead', 'head not found id: ', p_iIndex); }
			}
			catch (e:Error)
			{
				// if the head cannot be instantiated, we ignore it
				Debug.traceInfo('ClipContainer', 'setDefaultHead', 'head cannot be instantiated', 'err : ' + e.message);
			}
		}
		
		public function setDefaultHead(p_iIndex:uint, p_sClass:String, p_aMarkers:Array) : void
		{
			var oBitmap : Bitmap;
			try
			{
				Debug.traceInfo('ClipContainer', 'setDefaultHead', 'default head', p_sClass);
				// instantiate the classes from the given string   实例化类从给定的字符串
				if (this.loaderInfo.applicationDomain.hasDefinition(p_sClass))
				{
					// get the class from the right application domain (needed because movie is loaded within another movie)
					//得到这个类的正确的应用程序域(需要,因为电影是加载在另一部电影)加载
					var oHeadClass:Class = this.loaderInfo.applicationDomain.getDefinition(p_sClass) as Class;
					var oImage:BitmapData = new oHeadClass();
					setHead(p_iIndex, new Bitmap(oImage), p_aMarkers);
				}
				else
				{
					Debug.traceInfo('ClipContainer', 'setDefaultHead', 'definition not found', p_sClass);
				}
			} catch (e:Error) {
				// if the head cannot be instantiated, we ignore it
				Debug.traceInfo('ClipContainer', 'setDefaultHead', 'head cannot be instantiated', p_sClass + ' : ' + e.message);
			}
		}
		
		public function addOverlayEvent(p_iIndex:uint, p_iStartFrame:uint, p_iDuration:uint, p_iType:uint, p_oData:Object):void {
			if (null != m_oEventTrigger) {
				m_oEventTrigger.addEvent(p_iIndex, p_iStartFrame, p_iDuration, p_iType, p_oData);
			}
			// set listener to intended overlay
			var oOverlay:Overlay = getHead(p_iIndex);
			if (null != oOverlay) {
				oOverlay.addEventType(p_iType, m_oEventTrigger);
			}
		}
		
		/**
		 * called from the constructor of the heads (which are instantiated by flash)
		 * NOTE the heads must be named 'head_x' where x is the id of the head
		 * @param uint p_iIndex The index of the current to add
		 * @param Head p_oHead The Head object
		 */
		public function addHead(p_iIndex:uint, p_oHead:Head) : void
		{
			Debug.traceInfo('ClipContainer', 'addHead', 'id', p_iIndex + ', frame: ' + currentFrame);
			if ((m_aHeads[p_iIndex] == undefined) || (m_aHeads[p_iIndex] == null))
			{
				m_aHeads[p_iIndex] = p_oHead;
				m_iNrHeads++;
			}
			else
			{
				// head already existed, replace the head object and set the image and filters of the old head
				//Debug.traceInfo('ClipContainer', 'addHead', 'head already exists: ' + p_iIndex);
				var oImage : DisplayObject = Head(m_aHeads[p_iIndex]).image;
				//Debug.traceInfo('ClipContainer', 'addHead', 'current image: ' + oImage);
				p_oHead.image = oImage;
				p_oHead.mouth = Head(m_aHeads[p_iIndex]).mouth;
				p_oHead.visible = true;
				if (!contains(p_oHead)) { addChild(p_oHead); }
				m_aHeads[p_iIndex] = p_oHead;
			}
			currHeadIndex = p_iIndex;
			self.dispatchEvent(new Event("CLIPCONTAINER_ADDHEAD"));
			headChange = true;
		}
		
		public function set status(p_sStatus:String):void
		{
			if (m_sStatus != p_sStatus) {
				m_sStatus = p_sStatus;
				// status has changed, dispatch event
				dispatchEvent(new Event(m_sStatus, true, false));
				//m_sOldStatus = m_sStatus;
				Debug.traceInfo('ClipContainer', 'status', 'status changed', m_sStatus);
				switch (m_sStatus) {
					case STATUS_ENDED :
						m_iCurrentFrame = 1;
						status = STATUS_WAITING_FOR_REPLAY;
					break;
					case STATUS_UNKNOWN :
					case STATUS_WAITING_FOR_INIT :
					case STATUS_INITIALIZED :
					case STATUS_PLAYING :
					case STATUS_PAUSED :
					case STATUS_WAITING_FOR_REPLAY :
					default :
						// do nothing
					break;
				}
			}
		}
		
		public function get status():String
		{
			return m_sStatus;
		}

		/**
		 * override public function play():void { Debug.traceInfo('ClipContainer', 'play');
		 * throw new Error('use start() to start the clip'); super.play(); } override
		 * public function stop():void { Debug.traceInfo('ClipContainer', 'stop'); throw
		 * new Error('use end() or pause() to stop the clip'); super.stop(); }
		 */
		public function start():void
		{
			Debug.traceInfo('ClipContainer', 'start');
			if (status != STATUS_PLAYING)
			{
				if (status == STATUS_WAITING_FOR_REPLAY)
				{
					// restart movie
					showHeads();
					resume();
				}
				else if (status == STATUS_INITIALIZED)
				{
					status = STATUS_PLAYING;
					super.play();
				}
				else { Debug.traceInfo('ClipContainer', 'start', 'incorrect status', status); }
			}
		}
		
		/**
		 * after the clip has ended, call end to hide all heads
		 */
		public function end():void
		{
			Debug.traceInfo('ClipContainer', 'end');
			stop();
			for each (var oHead:Head in m_aHeads) {
				oHead.visible = false;
			}
			status = STATUS_ENDED;
		}
		
		public function pause():void
		{
			Debug.traceInfo('ClipContainer', 'pause');
			m_iCurrentFrame = currentFrame;
			stop();
			status = STATUS_PAUSED;
		}
		
		/**
		 * resume playing after pause
		 */
		public function resume():void
		{
			gotoAndPlay(m_iCurrentFrame);
			//dispatchEvent(new Event(STATUS_PLAYING, true, false));
			status = STATUS_PLAYING;
		}
		
		// show invisible heads just before playing
		private function showHeads() : void
		{
			Debug.traceInfo('ClipContainer', 'showHeads');
			for each (var oHead : Head in m_aHeads)
			{
				oHead.visible = true;
				var v : MovieClip = oHead.parent.getChildByName('old') as MovieClip;
				if ( v != null) { oHead.parent.removeChild(v); v.visible = false; }
			}
		}
		
		private function onAddedToStage(p_oEvent:Event):void
		{
			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
			status = STATUS_WAITING_FOR_INIT;
		}
		
		private function onEnterFrame(p_oEvent : Event):void
		{
			if (headChange && false)
			{
				for each (var oHead : Head in m_aHeads)
				{
					var m: DisplayObjectContainer = oHead.parent;
					if (m.numChildren == 2) { m.removeChildAt(1); }
					//m.alpha ;
					//for (var j : int = m.numChildren - 1; j >= 0; j --)
					//{
					//	m.getChildAt(j).visible = false;
					//}
					//m.addChild(oHead);
					//m.visible = false;
					//if (m.parent) { m.parent.removeChild(m); }
					//oHead.alpha = .5;
					//if (m) { trace(m_aHeads[0].parent.numChildren); }
				}
				headChange = false;
			}
			switch (status)
			{
				case STATUS_WAITING_FOR_INIT :
					Debug.traceInfo('ClipContainer', 'onEnterFrame', 'STATUS_WAITING_FOR_INIT', m_iNrHeads + ' = ' + m_aHeads.length);
					if (m_iNrHeads == m_aHeads.length - 1)
					{
						Debug.traceInfo('ClipContainer', 'onEnterFrame', 'INITIALIZED');
						showHeads();
						// heads have been initialized, send event
						status = STATUS_INITIALIZED;
					}
				break;
				case STATUS_PLAYING :
					if (currentFrame >= totalFrames) {
						end();
					}
				break;
				case STATUS_UNKNOWN :
				case STATUS_INITIALIZED :
				case STATUS_PAUSED :
				case STATUS_ENDED :
				case STATUS_WAITING_FOR_REPLAY :
				default :
					// do nothing
				break;
			}
			// let OverlayEventTrigger handle the frame
			m_oEventTrigger.handleFrame(currentFrame);
			if (self.currentLabel == sayState) { return; }
			sayState = self.currentLabel;
			if (sayState.slice(0, 3) == "SAY")
			{
				for each (var p : String in sayState.replace("SAY", "").split("|"))
				{
					var ps : Array = p.split(",");
					var h : Head = Head(m_aHeads[ps[0]]);
					if (h != null) { h.say(ps[1], ps[2], ps[3]); }
				}
			};
		}
		
	    public function getNrHeads(): int
	    {
			return m_iNrHeads;
	    }
		
		public function getHead(p_iIndex:int):Head
		{
			var oHead:Head = null;
			if ((p_iIndex >= 0) && (p_iIndex < m_aHeads.length)) {
				if ((undefined != m_aHeads[p_iIndex]) && (null != m_aHeads[p_iIndex])) {
					oHead = Head(m_aHeads[p_iIndex]);
				}
			}
			return oHead;
		}

		public function get eventTrigger(): OverlayEventTrigger
		{
			return m_oEventTrigger;
		}

		/**
		 * 
		 * @param p_oTrigger
		 */
		public function set eventTrigger(p_oTrigger:OverlayEventTrigger): void
		{
			m_oEventTrigger = p_oTrigger;
		}

	}

}