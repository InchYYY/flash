///////////////////////////////////////////////////////////
//  Head.as
//  Macromedia ActionScript Implementation of the Class Head
//  Generated by Enterprise Architect
//  Created on:      18-okt-2010 13:03:59
//  Original author: Wouter Tengeler
///////////////////////////////////////////////////////////

package nl.funnymessages.overlay.head
{
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.filters.BitmapFilter;
	import flash.filters.BlurFilter;
	import flash.filters.ColorMatrixFilter;
	import flash.utils.getQualifiedClassName;
	
	import nl.funnymessages.overlay.Overlay;
	import nl.funnymessages.overlay.OverlayEventTrigger;
	import nl.funnymessages.overlay.OverlayEvent;
	import nl.funnymessages.overlay.head.Mouth;
	import nl.funnymessages.clipcontainer.ClipContainer;

	import nl.themotionstudio.utils.ObjectCloner;
	
	import nl.themotionstudio.utils.Debug;

	/**
	 * @author Wouter Tengeler
	 * @version 1.0
	 * @created 18-okt-2010 13:03:59
	 */
	public class Head extends Overlay
	{
		public static const MARKER_MOUTH_LEFT:String = 'mouthleft';
		public static const MARKER_MOUTH_RIGHT:String = 'mouthright';
		public static const MARKER_MOUTH_BOTTOM:String = 'mouthbottom';
		public var ID : int;
		
	    private var m_oImage:DisplayObject;
	    private var m_oMouth:Mouth;
		private var m_aAnimation:Array;
		private var m_aFilters:Array;
		private var m_bUseMouth:Boolean;

	    public function Head(): void
	    {
			Debug.addClass('Head');
			Debug.traceInfo('Head', 'constructor', 'this', this.name);
			super();
			var oContainer:ClipContainer = findParentContainer();
			if (null != oContainer) { oContainer.addHead(id, this); }
			else
			{
				Debug.traceInfo('Head', 'constructor', 'No parent ClipContainer found', this.name);
				// Head should be within children of ClipContainer, error
				throw new Error('The Head object with id: ' + this.name + ' is no child (or descendant) of the ClipContainer object');
			}
			//m_oMouth = null;
			//m_oImage = null;
			//m_aAnimation = new Array();
			//m_aFilters = new Array();
			m_bUseMouth = true;
			//this.visible = false;
	    }

	    /**
	     * 
	     * @param uint p_iType
	     * @param OverlayEventTrigger p_oTrigger
	     */
	    override public function addEventType(p_iType:uint, p_oTrigger:OverlayEventTrigger): void
	    {
			// set listeners for specific event types 
			switch (p_iType)
			{
				case OverlayEventTrigger.EVENT_TYPE_FILTER : 
					p_oTrigger.addEventListener(OverlayEvent.OVERLAY_EVENT_FILTER_START, onFilterStart);
					p_oTrigger.addEventListener(OverlayEvent.OVERLAY_EVENT_FILTER_END, onFilterEnd);
					break;
				case OverlayEventTrigger.EVENT_TYPE_SPEECH :
					p_oTrigger.addEventListener(OverlayEvent.OVERLAY_EVENT_SPEECH_START, onSpeechStart);
					p_oTrigger.addEventListener(OverlayEvent.OVERLAY_EVENT_SPEECH_END, onSpeechEnd);
					break;
				default : // not supported by this overlay type
			}
	    }		
		
		public function createMouth(p_aMarkers:Array) : void
		{
			if (m_bUseMouth) {
				// only create a mouth if it is used anyway
				if (null != m_oImage) {
					if (null != m_oMouth) {
						// if we already had a mouth, remove it
						if (contains(m_oMouth)) {
							removeChild(m_oMouth);
						}
						m_oMouth = null;
					}
					m_oMouth = new Mouth();
					m_oMouth.createImage(m_oImage, p_aMarkers);
					addChild(m_oMouth);
				} else {
					throw new Error('mouth cannot be created without a head image');
				}
			}
		}
		
	    /**
		 * 
		 * @param p_sPhonem
		 */
	    public function say(p_sPhonem:String): void
	    {
			Debug.traceInfo('Head', 'say', 'phonem', p_sPhonem);
			if (null != m_oMouth) {
				m_oMouth.say(p_sPhonem);
			}
	    }

		/**
		 * 
		 * @param p_oMouth
		 */
		public function set mouth(p_oMouth:Mouth): void
		{
			if ((null != m_oMouth) && (contains(m_oMouth))) {
				removeChild(m_oMouth);
				m_oMouth = null;
			}
			
			m_oMouth = p_oMouth;
			if (null != m_oMouth) {
				addChild(m_oMouth);
			}
		}

		public function get mouth(): Mouth
		{
			return m_oMouth;
		}

		/**
		 * 
		 * @param p_bmpImage
		 */
		public function set image(p_oImage : DisplayObject): void
		{
			Debug.traceInfo('Head', 'image setter: (' + this.name + ')');
			if ((m_oImage != null) && (contains(m_oImage)))
			{
				removeChild(m_oImage);
				m_oImage = null;
			}
			if (p_oImage != null)
			{
				//Debug.traceInfo('Head', 'image setter: (' + this.name + ')', 'image', p_oImage.name);
				// clone the image so the reference is decoupled
				//m_oImage = ObjectCloner.cloneDisplayObject(p_oImage);
				m_oImage = p_oImage;
				// set the filters to the new image
				m_oImage.filters = m_aFilters;
				
			}
			else
			{
				//Debug.traceInfo('Head', 'image setter: (' + this.name + ')', 'new image = null');
				// remove head image
				m_oImage = null;
			}
			// show image if it is not null
			if (m_oImage != null) {
				addChild(m_oImage);
			}
			
			// make sure the mouth is always on top of the head, so we add the mouth again
			if (m_oMouth != null)
			{
				mouth = m_oMouth;
			}
		}

		public function get image(): DisplayObject
		{
			return m_oImage;
		}
		
		
		public function setSpeech(p_aTiming:Array):void {
			
		}
		
		/**
		 * It is possible to have a Head object within submovieclips of a ClipContainer object.
		 * We look for the ClipContainer object in the ancestors of the Head.
		 * @return ClipContainer | null returns the parent ClipContainer or null if it is not found
		 */
		private function findParentContainer():ClipContainer {
			var oParent:DisplayObject = this.parent;
			var bFound:Boolean = false;
			while ((oParent != null) && (!bFound)) {
				if (oParent is ClipContainer) {
					bFound = true;
				} else {
					// get the parent's parent
					try {
						oParent = oParent.parent;
					} catch (e:Error) {
						// something wrong, quit search
						oParent = null;
					}
				}
			}
			if (!bFound) {
				oParent = null;
			}
			return oParent as ClipContainer;
		}
		
		private function addFilter(p_sFilter:String):void {
			var oFilter:BitmapFilter = null;
			switch(p_sFilter.toLowerCase()) {
				case 'black_white' :
					oFilter = getBlackAndWhiteFilter();
				break;
				default :
					// unknown filter, do nothing
					oFilter = null;
			}
			if (null != oFilter) {
				Debug.traceInfo('Head', 'addFilter', 'name', this.name + ', filter: ' + p_sFilter);
				// add the filter
				m_aFilters.push(oFilter);
				if (null != m_oImage) {
					m_oImage.filters = m_aFilters;
				}
			}
		}
		
		/**
		 * remove a filter from the list
		 * @param String p_sFilter
		 * @todo implement method
		 */
		private function removeFilter(p_sFilter:String) {
			Debug.traceInfo('Head', 'removeFilter', 'name', this.name + ', filter: ' + p_sFilter);
		}
		
		/**
		 * event handler for adding a filter
		 * @param OverlayEvent p_oEvent
		 */
		private function onFilterStart(p_oEvent:OverlayEvent):void {
			Debug.traceInfo('Head', 'onFilterStart', 'data', p_oEvent.eventObj);
			if (p_oEvent.eventObj.id == id) {
				// event is meant for me
				addFilter(p_oEvent.eventObj.name);
			}
		}

		/**
		 * event handler for adding a filter
		 * @param OverlayEvent p_oEvent
		 */
		private function onFilterEnd(p_oEvent:OverlayEvent):void {
			if (p_oEvent.eventObj.id == id) {
				// event is meant for me
				removeFilter(p_oEvent.eventObj.type);
			}
		}
		
		/**
		 * event handler for starting a speech animation
		 * @param OverlayEvent p_oEvent
		 */
		private function onSpeechStart(p_oEvent:OverlayEvent):void {
			if (p_oEvent.eventObj.id == id) {
				// event is meant for me
				Debug.traceInfo('Head', 'onSpeechStart', 'name', this.name + ', say: ' + p_oEvent.eventObj.say);
			}
		}
		/**
		 * event handler for starting a speech animation
		 * @param OverlayEvent p_oEvent
		 */
		private function onSpeechEnd(p_oEvent:OverlayEvent):void {
			if (p_oEvent.eventObj.id == id) {
				// event is meant for me
				Debug.traceInfo('Head', 'onSpeechEnd', 'name', this.name + ', say: ' + p_oEvent.eventObj.say);
			}
		}
		
		/**
		 * parse the id from the name of this object
		 * This is needed because overlays are added from the IDE
		 * @return uint The id
		 */
		override protected function parseId():uint
		{
			var iIndex:uint = 0;
			if (this.name.indexOf('head_') >= 0) {
				// get the index of the head from the name
				var aName:Array = this.name.split('_');
				if ((undefined != aName[1]) && (!isNaN(aName[1]))){
					iIndex = parseInt(aName[1]);
				} else {
					throw new Error('Head object has wrong name, should be "head_x"');
				}
			} else {
				throw new Error('Head object has wrong name, should be "head_x"');
			}
			ID = iIndex;
			return iIndex;
		}
		
		private function getBlackAndWhiteFilter():BitmapFilter {
			var rLum:Number = 0.2225;
            var gLum:Number = 0.7169;
            var bLum:Number = 0.0606;
			
			var aMatrix:Array = [rLum, gLum, bLum, 0, 0,
								rLum, gLum, bLum, 0, 0,
								rLum, gLum, bLum, 0, 0,
								0, 0, 0, 1, 0];
			var oFilter:ColorMatrixFilter = new ColorMatrixFilter(aMatrix);
			return oFilter;
		}
		
		private function getBlurFilter():BitmapFilter
		{
			var oFilter:BlurFilter = new BlurFilter(8, 8);
			return oFilter;
		}

	}//end Head

}